---
header-includes:
   \usepackage{amsmath}
   \usepackage{geometry}
   \usepackage{pdfpages}
   \usepackage{fontspec}
   \usepackage{pdfpages}
   \usepackage{graphicx}
   \usepackage{amsmath}
   \usepackage{atbegshi}
   \usepackage{fancyhdr}
   \usepackage{tocloft}
   \usepackage{tcolorbox}
   \usepackage{xcolor}
   \definecolor{bleu}{RGB}{0,0,255}
   \usepackage{everypage}
   \usepackage{everypage}
   \usepackage{graphicx}
   \usepackage{fancyhdr}
   \pagestyle{fancy} 
   \definecolor{mybrown}{RGB}{139,69,19}
   \fancyhead[R]{}
output: 
  pdf_document: 
    number_sections: true
    latex_engine: xelatex
    fig_height: 4
    fig_width: 5
    fig_caption: true
    keep_tex: true
lang: fr
bibliography: references.bib
urlcolor: blue
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: 72
---

\setcounter{tocdepth}{5}                
\renewcommand\contentsname{\begin{center}\textcolor{brown}{Sommaire}\end{center}}
\AtBeginShipout{
  \ifnum\value{page}=1\thispagestyle{empty}\fi}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\fancyhead[L]{El√®ves Ing√©nieurs}
\fancyhead[R]{\textcolor{brown}{@Alex, Ali, Richard \& Toussaint}}
\fancyfoot[C]{\thepage}
\fancyfoot[L]{Mars 2025}
\fancyfoot[R]{Projet Statistique}
\AddEverypageHook{
  \ifnum\value{page}>1 
    \fancyhead[L]{El√®ves Ing√©nieurs}
    \fancyhead[R]{\textcolor{brown}{@Alex, Ali, Richard \& Toussaint}}
    \fancyfoot[C]{\thepage}
    \fancyfoot[L]{Mars 2025}
    \fancyfoot[R]{Projet Statistique}
  \else
    \fancyhead[L]{} 
    \fancyhead[R]{}
    \fancyfoot[C]{}
    \fancyfoot[R]{}
  \fi
}
```{=latex}
\tableofcontents
```

\newpage

\renewcommand\listtablename{\begin{center}\textcolor{brown}{Liste des Tableaux}\end{center}}
\renewcommand\listfigurename{\begin{center}\textcolor{brown}{Liste des Figures}\end{center}} 

\setlength{\cftfignumwidth}{3em}
\setlength{\cfttabnumwidth}{3em}
```{=latex}
\listoftables
```

\newpage

```{=latex}
\listoffigures
```

\newpage

```{r setup, include=FALSE, fig.align='center'}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
```

```{r}
# Chargement des packages
library(stringi)
library(dplyr)
library(knitr)
library(tidyverse)
library(summarytools)
library(gridExtra)
library(purrr)
library(skimr)
library(spdep)
library(geosphere)
```

```{r }
# Importation des donn√©es de d√©monstration

demo <- read.csv("../data/demof2.csv", sep = ";", dec=",")
#View(demo)
#str(demo)
names(demo)[names(demo) == "Libell√©"] <- "libelle_maj"

## Fonction prenant en entr√©e un base et nettoie les noms des colonnes

nettoyer_noms_colonnes <- function(data){
  names(data) <- names(data) %>%
    stri_trans_general("Latin-ASCII") %>% # Suppression des accents
    gsub("\\s+", "_", .) %>% # Remplacement des espaces par des underscores
    gsub("\\.+", "_", .) %>% # Remplacement des points par des underscores
    tolower() # Conversion en minuscules
  return (data) 
}

## Nettoyage des colonnes de la base demo
demo <- nettoyer_noms_colonnes(demo)
#names(demo)


# Fusion des bases et cr√©ation des varaiables

## Importation de la base generalise
generalise <- read.csv("../data/generalise.csv", sep=";")
#str(generalise)

## Importation de la base pour les lon et lat manquantes
donnees_manquantes <- read.csv(
  "../data/communes_manquantes_latitudes_longitudes.csv", sep=";", dec=".")
#str(donnees_manquantes)

donnees_manquantes$longitude <- donnees_manquantes$longitude %>%
  str_replace_all(",", "") %>%  # Supprime les virgules
  as.numeric()

## Nettoyage dans les noms des colonnes
generalise <- nettoyer_noms_colonnes(generalise)
donnees_manquantes <- nettoyer_noms_colonnes(donnees_manquantes)

## Fusion des bases
data <- demo %>% 
  inner_join(generalise, by ="code") %>%
  left_join(donnees_manquantes, by = "code") %>%
  mutate(
    longitude = ifelse(is.na(longitude.x), longitude.y, longitude.x),
    latitude = ifelse(is.na(latitude.x), latitude.y, latitude.x)
  ) %>%
  select(-longitude.x, -longitude.y, -latitude.x, -latitude.y)


#nrow(demo)
#nrow(generalise)
#nrow(data)

## Filtrons les communes n'appartenant pas au d√©partement 97
data <- data %>% filter(departement != 97)



## Cr√©ation de la variable taux de visites
data <- data %>% 
  mutate(taux_visites = nb_visite/population_municipale_2021_x)

## Cr√©ation de la variabe taux de visites pour les plus de 19 ans
data <- data %>%
  mutate(pop_19_ans_ou_plus = pop_15_ans_ou_plus - pop_15_19_ans,
       taux_visites_19_ans_ou_plus = nb_visite / pop_19_ans_ou_plus)

#summary(data$taux_visites)
#summary(data$taux_visites_19_ans_ou_plus)

#skim(data)




## Exportation de la base finale 
write.csv(data, "../data/data.csv", row.names = FALSE)

```

# \textcolor{brown} {Introduction}

La r√©partition g√©ographique des besoins en soins de sant√© est un enjeu majeur pour les politiques publiques, notamment en ce qui concerne l'acc√®s aux services de m√©decine de ville. Les in√©galit√©s territoriales dans l'offre et la demande de soins peuvent entra√Æner des disparit√©s significatives en mati√®re de sant√©, affectant particuli√®rement les populations vivant dans des zones sous-dot√©es en professionnels de sant√©. Comprendre ces dynamiques spatiales et socio-d√©mographiques est essentiel pour identifier les zones prioritaires et orienter les d√©cisions en mati√®re d'allocation des ressources.

Dans ce contexte, ce travail propose une mod√©lisation du nombre de consultations en m√©decine de ville √† l'√©chelle communale, en tenant compte des caract√©ristiques d√©mographiques, socio-√©conomiques et spatiales des communes. L'objectif est double : d'une part, analyser les facteurs influen√ßant la demande de soins, et d'autre part, identifier les zones susceptibles de d√©passer un seuil critique de "d√©sert m√©dical". Pour ce faire, nous nous appuierons sur une base de donn√©es riche et vari√©e, comprenant des informations issues du Syst√®me National des Donn√©es de Sant√© (SNDS) pour la p√©riode 2018-2022, ainsi que des indicateurs socio-d√©mographiques et g√©ographiques.

Notre approche m√©thodologique repose sur une combinaison de techniques statistiques et spatiales. Nous commencerons par une analyse descriptive et cartographique des donn√©es pour visualiser les tendances et les disparit√©s territoriales. Ensuite, nous utiliserons des mod√®les de r√©gression de Poisson pour mod√©liser le nombre de consultations annuelles, en tenant compte des effets fixes (caract√©ristiques des communes) et des effets al√©atoires (variations spatiales). Enfin, une r√©gression logistique binaire sera employ√©e pour √©valuer la probabilit√© qu'une commune d√©passe un seuil pr√©d√©fini de "d√©sert m√©dical".

Ce travail s'inscrit dans une perspective √† la fois acad√©mique et op√©rationnelle. Sur le plan acad√©mique, il contribue √† l'√©tude des in√©galit√©s territoriales en sant√© en proposant une m√©thodologie robuste pour l'analyse spatiale des donn√©es de soins. Sur le plan op√©rationnel, il fournit des outils pour identifier les zones prioritaires et soutenir la prise de d√©cision en mati√®re de politiques de sant√© publique.


\newpage


# \textcolor{brown} {Pr√©sentation du contexte}

## Int√©r√™t de l'√©tude

## Cadre conceptuel de l'√©tude

Dans cette partie, nous allons d√©finir certainses notions cl√©s qui apparaissent dans notre √©tude entre autres, le nombre de visites, le nombre de visites esp√©r√©s ainsi que le taux de visite. 

1. Nombre de visites esp√©r√©s

Le nombre de visite esp√©r√©s, terme qui apparaitra dans notre mod√©lisation est le nombre de visite qu'il y aurait eu dans chaque commune si le taux de visite √©tait le m√™me dans dans ces derni√®res. En d'autres terme si $r$ est le taux moyen de visite alors, le nombre de visite escompt√© not√© $\mu$ est calcul√© par :

\begin{tcolorbox}[colback=mybrown!10!white, colframe=mybrown!80!black, boxrule=0.5mm]
$$ \mu_i = r * P_i$$
\end{tcolorbox}


o√π $P_i$ est le nombre d'habitants dans la commune $i$

2. Taux de visite

Le taux de visite n'est rien d'autre que le nombre moyen de visite dans chaque commune. IL est calcul√© en divisant le nombre de visite par la population de la commune en question. En d'autres termes, il s'agit du nombre de visites que chaque habitant de la commune a effectu√© en moyenne. 

\begin{tcolorbox}[colback=mybrown!10!white, colframe=mybrown!80!black, boxrule=0.5mm]
$$\tau_i = \frac{n_i}{P_i}$$
\end{tcolorbox}
o√π $\tau_i$ et $n_i$ sont respectivement le taux et le nombre de visite de la commune $i$. 



## Revue de litt√©rature

La mod√©lisation des visites dans les h√¥pitaux est cruciale pour
comprendre les dynamiques de la sant√© publique et pour optimiser la
gestion des ressources m√©dicales. Dans ce contexte, les mod√®les de
r√©gression de type Poisson g√©n√©raux, en particulier les mod√®les mixtes
g√©n√©ralis√©s (GLMM), sont souvent utilis√©s pour g√©rer les donn√©es de
comptage, en tenant compte des sp√©cificit√©s d√©mographiques et
g√©ographiques des agglom√©rations, ici d√©finies par les communes.

Les recherches ant√©rieures, comme celles de Mohebbi et al. (2011),
montrent l'importance d'int√©grer des effets spatiaux dans les mod√®les de
comptage, surtout lorsqu'on √©value des ph√©nom√®nes tels que le cancer
≈ìsophagien (EC) dans des provinces sp√©cifiques. Leur √©tude souligne
comment la non-prise en compte de l'autocorr√©lation spatiale peut
conduire √† une estimation biais√©e des effets des variables
socio-√©conomiques sur l'incidence des maladies. Ce ph√©nom√®ne pourrait
√©galement s'appliquer √† la mod√©lisation des visites √† l'h√¥pital, o√π
certains facteurs ouent un r√¥le significatif.

Selon l'article, trois structures d'autocorr√©lation peuvent √™tre
appliqu√©es dans le cadre de la r√©gression Poisson lorsqu'on traite des
donn√©es de comptage. Ces mod√®les comprennent : 

1. **Mod√®le Poisson avec effets al√©atoires non spatiaux** : Bien qu'utiles, ces mod√®les n√©gligent
l'autocorr√©lation spatiale, ce qui peut conduire √† une sous-estimation
des erreurs standard. 

2. **Mod√®le avec effets al√©atoires spatiaux bas√©s sur la distance** : Ce mod√®le prend en compte l'influence des
agglom√©rations voisines, mais peut ne pas capturer efficacement
l'h√©t√©rog√©n√©it√© locale. 

3. **Mod√®le avec effets al√©atoires de type voisinage** : Utilisant la structure conditionnelle autor√©gressive (CAR),
ce mod√®le est le plus adapt√© pour les donn√©es spatiales en int√©grant les
interactions entre les communes. Pour notre √©tude, le mod√®le avec effets
al√©atoires de type voisinage est recommand√© pour la mod√©lisation du
nombre de visites √† l'h√¥pital en France, car il permet de mieux prendre
en compte l'effet de proximit√© entre communes.

L'application des principes issus de l'article de Mohebbi et al. peut
enrichir notre √©tude sur la fr√©quentation des h√¥pitaux en France. En
int√©grant des effets al√©atoires spatiaux adapt√©s √† la structure des
donn√©es, nous pouvons r√©aliser des estimations plus pr√©cises et utiles
pour la planification hospitali√®re.

En ce qui concerne les facteurs explicatifs du nombre de visite dans les
hopitaux, plusieurs √©tudes se sont pench√©es sur ce sujet. De nombreuses
√©tudes ont montr√© que le nombre de consultations m√©dicales est influenc√©
par divers facteurs sociod√©mographiques, allant des caract√©ristiques
individuelles aux contextes socio-√©conomiques et territoriaux.

1.  Influence de l‚Äô√¢ge et du sexe

L‚Äô√¢ge constitue un d√©terminant majeur du recours aux soins. Les
personnes √¢g√©es, en particulier celles de 65 √† 79 ans, consultent plus
fr√©quemment en raison de la pr√©valence accrue de maladies chroniques et
du suivi m√©dical n√©cessaire √† leur prise en charge [@statcan2022]. En revanche, la population jeune et en bonne sant√© pr√©sente
une utilisation plus sporadique des services m√©dicaux. Le sexe est
√©galement un facteur diff√©renciant important. De mani√®re g√©n√©rale, les
femmes consultent plus fr√©quemment que les hommes. Cette diff√©rence est
attribu√©e aux besoins sp√©cifiques en sant√© reproductive, mais aussi √†
une plus grande propension √† rechercher des soins pr√©ventifs [@bag2024]. En revanche, les hommes,
notamment dans les cat√©gories socio-professionnelles les plus actives,
ont tendance √† sous-utiliser les services de soins, ce qui peut
entra√Æner des diagnostics plus tardifs et des complications m√©dicales
accrues.

2.  Impact du statut socio-√©conomique et du niveau d‚Äô√©ducation

Le revenu et la pr√©carit√© √©conomique influencent consid√©rablement
l‚Äôacc√®s aux soins. Les individus √† revenu √©lev√© b√©n√©ficient g√©n√©ralement
d‚Äôun meilleur acc√®s aux consultations m√©dicales, notamment gr√¢ce √† une
plus grande couverture sociale et des assurances compl√©mentaires leur
permettant de r√©duire les co√ªts associ√©s aux soins [@bvs2023]. √Ä l‚Äôinverse, les personnes en situation de pr√©carit√©
rencontrent des obstacles financiers, administratifs et culturels qui
limitent leur recours aux soins, malgr√© des besoins souvent accrus en
raison de conditions de vie plus pr√©caires. Le niveau d‚Äô√©ducation joue
un r√¥le cl√© dans la fr√©quentation des services de sant√©. Une instruction
plus √©lev√©e est associ√©e √† une meilleure connaissance des risques
sanitaires et √† une adoption plus proactive des comportements de
pr√©vention, ce qui entra√Æne un recours plus fr√©quent aux soins m√©dicaux
[@bvs2023]. En revanche, un faible niveau d‚Äô√©ducation est
souvent corr√©l√© √† un moindre suivi m√©dical et √† une utilisation plus
tardive des services de soins, notamment en cas de complications.

3.  Influence du contexte familial et de l‚Äôenvironnement social

L‚Äô√©tat matrimonial influence √©galement la fr√©quence des consultations
m√©dicales. Les personnes mari√©es ou vivant en couple consultent
davantage, b√©n√©ficiant du soutien d‚Äôun conjoint qui peut inciter √†
prendre soin de sa sant√© et √† consulter r√©guli√®rement un m√©decin
[@statcan2022]. Par ailleurs, l‚Äôacc√®s √† un m√©decin
traitant ou de famille constitue un d√©terminant important. Les patients
disposant d‚Äôun suivi m√©dical r√©gulier sont plus enclins √† effectuer des
consultations pr√©ventives et √† √™tre orient√©s rapidement vers des
sp√©cialistes si n√©cessaire [@statcan2022]. 

4. Perception de l‚Äô√©tat de sant√© et acc√®s g√©ographique aux soins 

La perception de la sant√© est un facteur d√©terminant du recours aux soins.
Les individus qui consid√®rent leur √©tat de sant√© comme excellent ou tr√®s
bon consultent rarement, tandis que ceux qui ont une perception n√©gative
de leur √©tat de sant√© ont tendance √† multiplier les visites m√©dicales
[@statcan2022]. Enfin, les in√©galit√©s spatiales dans
l‚Äôacc√®s aux soins modulent √©galement la fr√©quence des consultations. En
milieu urbain, la densit√© m√©dicale plus √©lev√©e facilite l‚Äôacc√®s aux
services de soins, tandis qu‚Äôen zones rurales ou m√©dicalement
sous-dot√©es, les d√©lais d‚Äôattente et les distances √† parcourir
constituent des freins majeurs [@irdes2020].


\newpage



# \textcolor{brown} {M√©thodologie}

## Pr√©sentation des donn√©es

Les donn√©es que nous avons utilis√©es nous proviennent de ...


## Motivation

Les mod√®les lin√©aires g√©n√©ralis√©s √† effets mixtes (GLMM) combinent :

-   Les caract√©ristiques des mod√®les lin√©aires g√©n√©ralis√©s (GLM) pour
    mod√©liser des variables non-normalement distribu√©es.

-   Les propri√©t√©s des mod√®les √† effets mixtes pour g√©rer des donn√©es
    group√©es ou hi√©rarchiques.

## Mod√®les Lin√©aires G√©n√©ralis√©s

Un GLM relie le pr√©dicteur lin√©aire $\eta$ √† la moyenne $\mu$ de la
r√©ponse √† travers une fonction de lien $g$ :\
$$ g(\mu) = \eta = \beta_0 + \sum_{i=1}^m \beta_i x_i $$\
Les distributions possibles incluent :

-   **Normale** : R√©gression lin√©aire classique, avec lien identit√©.

-   **Binomiale** : R√©gression logistique pour donn√©es binaires, avec
    lien logit.

-   **Poisson** : R√©gression de Poisson pour donn√©es de comptage, avec
    lien logarithmique.

### R√©gression Logistique

Mod√©lise une r√©ponse binaire ($y \sim B(n, p)$), o√π $p$ est la
probabilit√© de succ√®s :\
$$ P(y | n, p) = \binom{n}{y} p^y (1-p)^{n-y} $$\
La probabilit√© $p$ est reli√©e au pr√©dicteur par la fonction logistique
:\
$$ p = \frac{1}{1 + e^{-\eta}} \quad \text{o√π} \quad \eta = \beta_0 + \sum_{i=1}^m \beta_i x_i. $$\
Le log-vraisemblance est exprim√© comme :\

\begin{tcolorbox}[colback=mybrown!10!white, colframe=mybrown!80!black, boxrule=0.5mm]
$$ \ell(\boldsymbol{\beta}) = \sum_{i=1}^n \left[ y_i \log{p_i} + (1-y_i) \log{(1-p_i)} \right]. $$
\end{tcolorbox}

### R√©gression de Poisson

Utilis√©e pour mod√©liser des donn√©es de comptage
($y \sim Pois(\lambda)$), o√π $\lambda$ est la moyenne et la variance :\
$$ P(y | \lambda) = \frac{\lambda^y}{y!} e^{-\lambda} $$\
Le lien logarithmique assure $\lambda > 0$ :\
$$ \log{\lambda} = \beta_0 + \sum_{i=1}^m \beta_i x_i $$\
L'esp√©rance est $E[y] = \lambda$.

## Mod√®les Lin√©aires Mixtes

Ces mod√®les ajoutent des termes d'effets al√©atoires
$\mathbf{Z} \mathbf{u}$ au pr√©dicteur lin√©aire :\
$$ \mathbf{y} = \mathbf{X} \boldsymbol{\beta} + \mathbf{Z} \mathbf{u} + \boldsymbol{\varepsilon}, $$\
avec :

-   $\mathbf{u} \sim N(\mathbf{0}, \mathbf{G})$, les effets al√©atoires.

-   $\boldsymbol{\varepsilon} \sim N(\mathbf{0}, \mathbf{R})$, les
    r√©sidus.

La matrice de covariance totale est :\
$$ \mathrm{Var}(\mathbf{y}) = \mathbf{Z} \mathbf{G} \mathbf{Z}^T + \mathbf{R}. $$\
Les param√®tres sont estim√©s par maximum de vraisemblance (ML) ou par
vraisemblance restreinte (REML).

## Mod√®les Lin√©aires G√©n√©ralis√©s √† Effets Mixtes (GLMM)

Un GLMM √©tend les GLM en int√©grant des effets al√©atoires :\
$$ g(\mu) = \mathbf{X} \boldsymbol{\beta} + \mathbf{Z} \mathbf{u}, $$\
o√π :\
- $g(\cdot)$ est la fonction de lien.\
- $\mathbf{u} \sim N(\mathbf{0}, \mathbf{G})$ est le vecteur d'effets
al√©atoires.

Les param√®tres sont estim√©s via des m√©thodes comme :\
- Approximations Laplaciennes.\
- Quadrature gaussienne adaptative.\
- M√©thodes MCMC (cha√Ænes de Markov Monte Carlo).

## Pr√©dictions et Simulations

Les GLMM permettent deux types de pr√©dictions :\
- **Conditionnelles** : Bas√©es sur les effets al√©atoires sp√©cifiques
($\mathbf{u}$).\
- **Marginales** : En int√©grant sur les effets al√©atoires.

Les simulations utilisent des approches param√©triques pour √©valuer la
variabilit√© et tester les hypoth√®ses. Une approche courante est le
bootstrap param√©trique :\
1. G√©n√©rer des donn√©es simul√©es bas√©es sur les param√®tres estim√©s.\
2. R√©ajuster le mod√®le pour chaque jeu de donn√©es simul√©.\
3. Analyser la distribution des estimations obtenues.

# \textcolor{brown} {Analyse des r√©sultats}

## Analyse descriptive

1. Description de la population d'√©tude 


Notre population d'√©tude est une population assez homog√®ne en mati√®re d'√¢ge. Cependant plus on d√©passe les 75 ans et moins on rencontre de personnes. D'autres part notre popuplation est fortement masculine avec une forte proportion des hommes quelle que soit la tranche d'√¢ge √† l'exception des tranches du troisi√®me √¢ge. 
```{r , fig.align='center', fig.cap= "Pyramide des √¢ges"}
library(ggplot2)
library(dplyr)
library(tidyr)
df = data
colnames(df) <- gsub("homme_", "hommes_", colnames(df))
colnames(df) <- gsub("hommes_70_47$", "hommes_70_74", colnames(df))



# S√©lectionner les colonnes de la pyramide des √¢ges
age_groups <- c("0_4", "5_9", "10_14", "15_19", "20_24", "25_29", "30_34", "35_39",
                "40_44", "45_49", "50_54", "55_59", "60_64", "65_69", "70_74",
                "75_79", "80_84", "85_89", "90_94", "95_plus")

# Restructurer les donn√©es pour la visualisation
hommes_vars <- intersect(colnames(df), paste0("hommes_", age_groups))
femmes_vars <- intersect(colnames(df), paste0("femmes_", age_groups))

# Cr√©er la pyramide des √¢ges avec les hommes d'abord, puis les femmes
pyramide <- data.frame(
  Age = rep(age_groups, 2),  # Liste tous les √¢ges d'abord pour les hommes, puis pour les femmes
  Sexe = c(rep("Homme", length(age_groups)), rep("Femme", length(age_groups))),
  Population = c(colSums(df[paste0("hommes_", age_groups)], na.rm=TRUE),
                 -colSums(df[paste0("femmes_", age_groups)], na.rm=TRUE))  # Femmes en n√©gatif
)



ggplot(pyramide, aes(x=Age, y=Population, fill=Sexe)) +
  geom_bar(stat="identity", width=0.8) +
  coord_flip() +  # Pour afficher en pyramide
  scale_y_continuous(labels = abs) +  # Afficher les valeurs absolues
  labs(
       x="Tranche d'√¢ge",
       y="Population",
       fill="Sexe") +
  theme_minimal() +
  scale_fill_manual(values=c("blue", "pink"))  # Couleurs pour Homme/Femme


```


Dans cette partie, nous allons r√©aliser quelques statistiques
descriptives sur nos donn√©es.

### Analyse univari√©e

```{r }
## Statistiques descriptives sur le nombre de visite

#summary(data$nb_visite)

```

1. Taux et Nombre de visites

L'analyse des statistiques descriptives sur le nombre de consultations
annuelles de m√©decin g√©n√©raliste entre 2018 et 2022 r√©v√®le une
distribution fortement asym√©trique √† droite, avec une grande dispersion
des donn√©es. La moyenne de 19130 consultations, nettement sup√©rieure √†
la m√©diane de 9127, indique la pr√©sence de valeurs extr√™mes tirant la
distribution vers le haut. Cette asym√©trie est confirm√©e par l'√©cart
consid√©rable entre le minimum de 1037 et le maximum de 765833
consultations par an.

La moiti√© des m√©decins g√©n√©ralistes effectuent entre 5993 et 17290
consultations annuellement, ce qui sugg√®re une variabilit√© importante
dans la charge de travail. La m√©diane de 9127 consultations par an,
√©quivalant √† environ 25 consultations par jour ouvrable, semble plus
repr√©sentative de l'activit√© typique d'un m√©decin g√©n√©raliste que la
moyenne influenc√©e par les valeurs extr√™mes. Ces statistiques mettent en
lumi√®re la diversit√© des pratiques et des charges de travail parmi les
m√©decins g√©n√©ralistes, avec potentiellement quelques cas atypiques
pr√©sentant un volume de consultations exceptionnellement √©lev√©.

Le nombre de visites pouvant potentiellement √™tre influenc√© par la
taille de la commune et donc par sa population, nous avons √©liminer cet
effet en calculant le taux de consultations qui n'est autre que le
nombre de consultations moyennes par personnes.

2. Taux de mortalit√© et de Natalit√©

Dans les commmunes √©tudi√©es, le taux de natalit√© et de mortalit√© sont un peu √©lev√©es avec la plupart des taux variant entre 5 et 15 pour 1000 en ce qui concerne la natalit√© et 0 et 20 pour 1000 pour la mortalit√©. On remarque une corr√©lation n√©gative entre ces deux taux. N√©anmoins cette corr√©lation n'a √† priori aucun sens. Par ailleurs, l'observation des distribution permet de constater que la natalit√© est nde fa√ßon g√©n√©rale √©lev√©e par rapport √† la mortalit√© dans les communes √©tudi√©es. 
```{r fig.align='center', fig.cap= "Taux de Natalit√© et Taux de Mortalit√©"}
# üìå V√©rification et conversion des variables avant de tracer
# V√©rification et conversion du taux de mortalit√©
if (class(df$taux_de_mortalite_annuel_moyen_2015_2021) != "numeric") {
  df$taux_de_mortalite_annuel_moyen_2015_2021 <- as.numeric(as.character(df$taux_de_mortalite_annuel_moyen_2015_2021))
}

# V√©rification et conversion du taux de natalit√©
if (class(df$taux_de_natalite_annuel_moyen_2015_2021) != "numeric") {
  df$taux_de_natalite_annuel_moyen_2015_2021 <- as.numeric(as.character(df$taux_de_natalite_annuel_moyen_2015_2021))
}

# üìå 1Ô∏è‚É£ Histogramme du taux de mortalit√©
p1 <- ggplot(df, aes(x = taux_de_mortalite_annuel_moyen_2015_2021)) +
  geom_histogram(bins = 30, fill = "red", alpha = 0.7, color = "black") +
  labs( 
       x = "Taux de mortalit√©", 
       y = "Nombre de communes") +
  theme_minimal()

# üìå 2Ô∏è‚É£ Histogramme du taux de natalit√©
p2 <- ggplot(df, aes(x = taux_de_natalite_annuel_moyen_2015_2021)) +
  geom_histogram(bins = 30, fill = "blue", alpha = 0.7, color = "black") +
  labs(
       x = "Taux de natalit√©", 
       y = "Nombre de communes") +
  theme_minimal()

# üìå 3Ô∏è‚É£ Nuage de points pour voir la relation entre mortalit√© et natalit√©
p3 <- ggplot(df, aes(x = taux_de_mortalite_annuel_moyen_2015_2021, 
                     y = taux_de_natalite_annuel_moyen_2015_2021)) +
  geom_point(alpha = 0.7, color = "purple") +
  geom_smooth(method = "lm", color = "black", linetype = "dashed") +  # Ajout d'une tendance lin√©aire
  labs(
       x = "Taux de mortalit√©",
       y = "Taux de natalit√©") +
  theme_minimal()

# üìå 4Ô∏è‚É£ Courbes de densit√© pour mieux voir la distribution
p4 <- ggplot(df) +
  geom_density(aes(x = taux_de_mortalite_annuel_moyen_2015_2021, fill = "Mortalit√©"), alpha = 0.5, color = "red") +
  geom_density(aes(x = taux_de_natalite_annuel_moyen_2015_2021, fill = "Natalit√©"), alpha = 0.5, color = "blue") +
  labs(
       x = "Taux",
       y = "Densit√©") +
  scale_fill_manual(values = c("Mortalit√©" = "red", "Natalit√©" = "blue")) +
  theme_minimal()

# üìå Affichage de tous les graphiques ensemble
library(gridExtra)
grid.arrange(p1, p2, p3, p4, ncol = 2)

```

```{r, fig.align='center', fig.cap= "R√©partition du nombre et du taux de consultations"}
library(ggplot2)
library(patchwork)

# Premier graphique pour nb_visite
plot1 <- ggplot(data) +
  aes(x = nb_visite) +
  geom_histogram(bins = 30L, fill = "gray") +
  theme_minimal() +
  ylab("Nombre de consultations") +
  xlab("")

# Deuxi√®me graphique pour taux_visites_19_ans_ou_plus
plot2 <- ggplot(data) +
  aes(x = taux_visites_19_ans_ou_plus) +
  geom_histogram(bins = 30L, fill = "gray") +
  theme_minimal() +
  ylab("Taux de consultations") +
  xlab("")

# Combinaison des deux graphiques
plot1 + plot2

```



### Analyse bivari√©e

Nous allons ici, voir s'il y a un lien √† priori entre le taux de
consultation et certaines de nos variables explicatives. Ainsi, nous
avons d'abord r√©alis√© une analyse descriptive bivari√©e puis nous avons
calcul√© la corr√©lation de Pearson pour √©valuer le lien lin√©aire entre le
taux de consulation et des variables telles que la population totale, la
part des personnes ag√©es (75 ans et plus), la part de quelques CSP
(ouvriers et retrait√©s).

#### Taux de consultation et population totale
$\\$
```{r}
# Calcul des quantiles
quantiles <- quantile(data$population_municipale_2021_x, probs = c(1/3, 2/3), na.rm = TRUE)

# Cr√©eation des classes avec les bornes des intervalles
data_pop <- data %>%
  mutate(taille_commune = case_when(
    population_municipale_2021_x <= quantiles[1] ~ paste0("Petite (<= ", round(quantiles[1]), ")"),
    population_municipale_2021_x <= quantiles[2] ~ paste0("Moyenne (", round(quantiles[1] + 1), " - ", round(quantiles[2]), ")"),
    TRUE ~ paste0("Grande (> ", round(quantiles[2]), ")")
  )) %>%
  group_by(taille_commune) %>%
  summarise("Taux de consulations"= mean(taux_visites, na.rm = TRUE))

# Affichage des r√©sultats dans le RMarkdown
kable(data_pop, caption = "Taux de consultations selon la taille de la commune")
```

En divisant les communes en trois groupes √©gaux (ou presque √©gaux) en
fonction de la population totale, il ressort qu'en moyenne, plus la
taille de la commune est importante plus le taux de consulations est
√©lev√©.

#### Taux de consultation et population √¢g√©e

```{r}
# Calcul de la m√©diane
mediane <- median(data$nb_de_pers_agees_de_75_ans_ou_plus_2021, na.rm = TRUE)

# Cr√©eation des classes avec les bornes des intervalles
data_age <- data %>%
  mutate(population_agee_importante = case_when(
    nb_de_pers_agees_de_75_ans_ou_plus_2021 <= mediane ~ paste0("Non (<= ", round(mediane), ")"),
    TRUE ~ paste0("Oui (> ", round(mediane), ")")
  )) %>%
  group_by(population_agee_importante) %>%
  summarise(consultations_moyennes = mean(taux_visites, na.rm = TRUE))

# Affichage des r√©sultats dans le RMarkdown
kable(data_age, caption = "Taux de consultations selon la population √¢g√©e")
```

```{r, fig.align='center', fig.cap="Relation entre taux de consultations et part des plus de 75 ans"}
ggplot(data = data, aes(x = part_des_pers_agees_de_75_ans_ou_2021 , y = taux_visites_19_ans_ou_plus)) +
  geom_point(color = "blue", size = 3) +          # Points bleus
  geom_smooth(method = "lm", se = TRUE, color = "red") +  # Droite de tendance (mod√®le lin√©aire)
  labs(
    x = "Part des plus de 75 ans",
    y = "Taux de consultation"
  ) +
  theme_minimal()

```

Les communes avec une population √¢g√©e importante (communes dont la
population √¢g√©e de 75 ans ou plus est sup√©rieure √† la m√©diane) ont en
moyenne un taux de consultations plus faible.

#### Taux de consultation et CSP
$\\$
```{r eval=FALSE, fig.align='center', fig.cap="Relations entre le taux de consultatiosn et certaines le nombre de certaines cat√©gories socioprofessionnelle", include=FALSE}
# Chargement les biblioth√®ques n√©cessaires
library(ggplot2)
library(gridExtra)

# Standarisation des variables pour prendre en compte l'effet de la taille des variables et rendre les comparaisons plus √©quitables
#data_csp <- data %>%
  #mutate(across(c(taux_visites, 13:20), scale))

data_csp <- data

# Cr√©ation les graphiques
plot1 <- ggplot(data_csp, aes(x = population_de_15_ans_ou_selon_la_csp_2021_agriculteurs_exploitants, y = taux_visites)) +
  geom_point() +
  labs(title = "", x = "Agriculteurs", y = "Taux de visites")

plot2 <- ggplot(data_csp, aes_string(x = names(data)[14], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Artisans", y = "Taux de visites")

plot3 <- ggplot(data_csp, aes_string(x = names(data)[15], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Cadres", y = "Taux de visites")

plot4 <- ggplot(data_csp, aes_string(x = names(data)[16], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Professions interm√©diaires", y = "Taux de visites")

plot5 <- ggplot(data_csp, aes_string(x = names(data)[17], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Employ√©s", y = "Taux de visites")

plot6 <- ggplot(data_csp, aes_string(x = names(data)[18], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Ouvriers", y = "Taux de visites")

plot7 <- ggplot(data_csp, aes_string(x = names(data)[19], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Retrait√©s", y = "Taux de visites")

plot8 <- ggplot(data_csp, aes_string(x = names(data)[20], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Sans activites", y = "Taux de visites")

# Affichage des graphiques ensemble
grid.arrange(plot1, plot2, plot3, plot4, plot5, plot6, plot7, plot8, ncol = 2)
```


Aucune cat√©gorie ne semble montrer une relation lin√©aire √©vidente avec
le taux de visite. Par ailleurs, pour toutes les cat√©gories
socio-professionnelles, la majorit√© des communes se situent dans une
plage de proportions faibles, ce qui limite la variabilit√© observable
dans les relations. Une analyse statistique suppl√©mentaire, comme le
calcul de corr√©lations, serait n√©cessaire pour confirmer ou infirmer les
relations observ√©es visuellement.

#### Analyse de corr√©lation

$\\$

Les r√©sultats de la corr√©lation de Pearson sont consign√©es dans le
tableau suivant :

```{r}
# Fonction de conversion
conversion_en_numeric <- function(data, columns) {
  resultat <- data %>%
    mutate(across(all_of(columns), as.numeric))
  return (resultat)
}
# Liste des variables √† tester avec taux_de_consultation
variables <- c("population_municipale_2021_x", "part_des_pers_agees_de_75_ans_ou_2021", 
               "population_de_15_ans_ou_selon_la_csp_2021_retraites", "population_de_15_ans_ou_selon_la_csp_2021_ouvriers")

data <- conversion_en_numeric(data, variables)


# Initialisation du tableau pour stocker les r√©sultats
resultats <- data.frame(Variable = character(), Correlation = numeric(), P_value = numeric())

# Calcul de la corr√©lation pour chaque variable et tester la significativit√©
for (var in variables) {
  test <- cor.test(data$taux_visites_19_ans_ou_plus, data[[var]], method = "pearson")
  resultats <- rbind(resultats, data.frame(
    Variable = var,
    Correlation = test$estimate,
    P_value = test$p.value
  ))
}

# Format du tableau avec la significativit√©
resultats$Significatif <- ifelse(resultats$P_value < 0.05, "Oui", "Non")

# Affichage du tableau dans le RMarkdown
kable(resultats, caption = "Corr√©lations de Pearson entre le taux de consultation et les autres variables")
```

Les r√©sultats nous montrent que le taux de consultation est positivement
corr√©l√© √† la population ainsi qu'√† celle de plus de 15 ans. Cependant la
corr√©lation est faible. Par ailleurs, la corr√©lation est n√©gative avec
la part des personnes ag√©es de plus de 75 ans. Cela dit, plus la part
des plus de 75 ans augmente moins est le taux de consultations dans une
commune. Cela peut vouloir dire que les personnes de plus de 75 ans sont
ceux qui ne se consultent pas assez.

```{r, fig.align='center', fig.cap= "Corr√©lations entre le nombre de visite et quelques variables"}
# S√©lectionner uniquement les variables d'int√©r√™t
# üìå D√©finition des noms lisibles pour les variables
nom_variables <- c(
  "taux_de_mortalite_annuel_moyen_2015_2021" = "Mortalit√©",
  "taux_de_natalite_annuel_moyen_2015_2021" = "Natalit√©",
  "part_des_familles_sans_enf_de_de_25_ans_2021" = "Sans enfants",
  "part_des_familles_avec_1_enf_de_de_25_ans_2021" = "Un enfant",
  "part_des_familles_avec_3_enf_ou_plus_de_de_25_ans_2021" = "Trois enfants",
  "nb_visite" = "Nombre de visites"
)

# üìå S√©lectionner les variables d'analyse
variables_analyse <- names(nom_variables)

df_analyse <- df[variables_analyse]

# üìå Convertir toutes les colonnes en num√©rique
df_analyse <- df_analyse %>% mutate(across(everything(), as.numeric))

# üìå Supprimer les valeurs manquantes
df_analyse <- na.omit(df_analyse)  

# üìå Calculer les corr√©lations
cor_matrix <- cor(df_analyse, use="complete.obs")

# üìå Trier les corr√©lations par ordre d√©croissant
cor_target <- sort(cor_matrix["nb_visite", ], decreasing=TRUE)

# üìå Remplacer les noms de variables par des noms plus lisibles
cor_data <- data.frame(
  Variable = names(cor_target),
  Correlation = cor_target
)

# üìå Appliquer les nouveaux noms
cor_data$Variable <- nom_variables[cor_data$Variable]

# üìå Exclure "Nombre de visites" du graphique
cor_data <- cor_data[cor_data$Variable != "Nombre de visites", ]

# üìå Afficher le barplot des corr√©lations
ggplot(cor_data, aes(x = reorder(Variable, Correlation), y = Correlation, fill = Correlation)) +
  geom_bar(stat="identity") +
  coord_flip() +
  scale_fill_gradient2(low="blue", mid="white", high="red", midpoint=0) +
  labs(
       x="Variables",
       y="Coefficient de corr√©lation") +
  theme_minimal()

```


### Autocorr√©lation

L‚Äôautocorr√©lation spatiale est une mesure essentielle pour analyser la
d√©pendance entre des observations g√©ographiques. Dans notre √©tude nos
donn√©es sont des donn√©es portant sur des communes. Ainsi il peut exister
une d√©pendance entre nos taux de consultations du fait de la proximit√©
des communes ou de l'appartenance √† un m√™me d√©partement ou r√©gion. Ainsi
nous allons mesurer cette d√©pendance en √©valuant l'autocorr√©lation
spatiale. Dans ce contexte, **l‚Äôindice de Moran** est largement utilis√©
pour quantifier cette d√©pendance en fournissant une mesure globale de
l‚Äôautocorr√©lation spatiale.

#### D√©finition de l‚Äôindice de Moran
$\\$
L‚Äôindice de Moran ($I$) √©value la similitude des valeurs d‚Äôune variable
entre diff√©rentes entit√©s g√©ographiques (par exemple, des communes) en
fonction de leur proximit√© spatiale. Il se base sur la matrice de poids
spatiale ($W$), qui d√©finit les relations entre ces entit√©s.

#### Formule de l‚Äôindice de Moran
$\\$
La formule math√©matique de l‚Äôindice de Moran est la suivante :

\begin{tcolorbox}[colback=mybrown!10!white, colframe=mybrown!80!black, boxrule=0.5mm]
$$
I = \frac{n}{\sum_{i=1}^n \sum_{j=1}^n w_{ij}} \cdot \frac{\sum_{i=1}^n \sum_{j=1}^n w_{ij} (x_i - \bar{x})(x_j - \bar{x})}{\sum_{i=1}^n (x_i - \bar{x})^2}
$$
\end{tcolorbox}

O√π :

-   $n$ : Nombre total d‚Äôentit√©s spatiales (Ici, le nombre de communes).

-   $x_i, x_j$ : Valeurs observ√©es de la variable pour les entit√©s $i$
    et $j$ (Ici le taux de consultations)

-   $\bar{x}$ : Moyenne de la variable $x$.

-   $w_{ij}$ : Poids spatial d√©finissant la relation entre $i$ et $j$.

La matrice de $W$ peut √™tre constuit sur la base du voisinage entre les
deux communes ou soit de la distance entre les deux communes. Dans le
premier cas alors $w_{ij}$ $w_{ij} = 1$ si $i$ et $j$ sont voisins et
$w_{ij} = 0$ sinon. Dans le second cas $w_{ij} = d_{ij}$. Nous allons
dans notre cas utiliser une matrice de poids bas√©e sur la distance,
notamment celle d'Haversine.

#### Matrice de poids bas√©e sur la distance de Haversine

#### D√©finition de la distance de Haversine

$\\$

La distance de Haversine est une mesure de la distance entre deux points
sur une sph√®re, bas√©e sur leurs coordonn√©es g√©ographiques ($latitude$ et
$longitude$). Elle est particuli√®rement utile pour les donn√©es
g√©ographiques projet√©es sur une surface sph√©rique, comme la Terre.


#### Formule de la distance de Haversine

$\\$

Si l'on consid√®re deux points ($i$) et ($j$), la distance ($d_{ij}$)
entre ces deux points sur la surface d'une sph√®re de rayon ($r$) est
donn√©e par :

\begin{tcolorbox}[colback=mybrown!10!white, colframe=mybrown!80!black, boxrule=0.5mm]
$$
 d_{ij} = 2r \cdot \arcsin\left(\sqrt{\sin^2\left(\frac{\phi_j - \phi_i}{2}\right) + \cos(\phi_i)\cos(\phi_j)\sin^2\left(\frac{\lambda_j - \lambda_i}{2}\right)}\right)
$$
\end{tcolorbox}

O√π : - $r$ : Rayon de la Terre (environ 6371 km).

-   $\phi_i, \phi_j$ : Latitudes des points $i$ et $j$ (en radians).

-   $\lambda_i, \lambda_j$ : Longitudes des points $i$ et $j$ (en
    radians). Apr√®s calcul nous avons ces statistiques sur nos
    distances.

```{r}
# Charger les biblioth√®ques n√©cessaires

#  (latitude, longitude)
library(spdep)     # Pour les fonctions de pond√©ration spatiale et test de Moran
library(geosphere) # Pour les calculs de distances g√©od√©siques

# V√©rification que les colonnes latitude et longitude existent dans `data`
if (!("latitude" %in% names(data)) || !("longitude" %in% names(data))) {
  stop("Les colonnes 'latitude' et 'longitude' doivent exister dans la base de donn√©es.")
}

# V√©rification des valeurs manquantes dans les coordonn√©es
if (anyNA(data$latitude) || anyNA(data$longitude)) {
  stop("Les colonnes 'latitude' et 'longitude' ne doivent pas contenir de valeurs manquantes.")
}

# Cr√©ation de la matrice des coordonn√©es
coords <- data.frame(
  lat = data$latitude,
  lon = data$longitude
)

# Calcul des distances g√©od√©siques (en m√®tres) avec la m√©thode de Vincenty
dist_matrix <- distm(coords, fun = distVincentySphere)/1000

# G√©rer les distances nulles ou infinies
if (any(diag(dist_matrix) != 0)) {
  diag(dist_matrix) <- 0  # Auto-distance d√©finie comme 0
}
if (any(is.infinite(dist_matrix))) {
  stop("La matrice des distances contient des valeurs infinies, v√©rifiez les coordonn√©es.")
}

# R√©sum√© statistique de toutes les distances
distance_values <- as.vector(dist_matrix)
#summary(distance_values)
```

Une visualtion de la densit√© de nos distance nous donne ceci, indiquant une forte asym√©trie √† gauche de la distribution. En d'autres termes,les communes √©tudi√©es sont assez rapproch√©es les unes des autres pour la plupart. 

```{r fig.align='center', fig.cap="Densit√© des distances"}
dist_df <- data.frame(Distance = as.vector(dist_matrix))
# Tracer la densit√©
ggplot(dist_df, aes(x = Distance)) +
  geom_density(fill = "blue", alpha = 0.4) +
  theme_minimal() +
  labs(x = "Distance", y = "Densit√©")

```

#### Construction de la matrice de poids

\
Pour construire la matrice de poids, nous avons alors suivi ces √©tapes.
\

1.  Calculer les distances de Haversine entre chaque paire d‚Äôentit√©s.
2.  D√©finir un seuil de distance maximale ($d_{max}$) :
    -   Si $d_{ij} < d_{max}$, $w_{ij} = \frac{1}{d_{ij}}$.
    -   Sinon, $w_{ij} = 0$.
3.  Normaliser les poids pour que chaque ligne de la matrice ait une
    somme √©gale √† 1 : $$
     w_{ij}^{norm} = \frac{w_{ij}}{\sum_{j} w_{ij}}.
    $$

```{r}
# Cr√©er la matrice de poids (inverse des distances)
weight_matrix <- 1 / dist_matrix
diag(weight_matrix) <- 0  # Aucun poids pour soi-m√™me

# G√©rer les cas o√π les distances sont nulles ou infinies
weight_matrix[is.infinite(weight_matrix)] <- 0

# Cr√©er l'objet spatial de pond√©ration
W <- mat2listw(weight_matrix, style = "W")

# V√©rifier que la variable √† analyser existe et ne contient pas de NA
if (!("taux_visites_19_ans_ou_plus" %in% names(data))) {
  stop("La colonne 'taux_visites_19_ans_ou_plus' doit exister dans la base de donn√©es.")
}
values <- data$taux_visites_19_ans_ou_plus

if (anyNA(values)) {
  stop("La colonne 'taux_visites_19_ans_ou_plus' ne doit pas contenir de valeurs manquantes.")
}

# Calcul de l'indice de Moran
moran_result <- moran.test(values, W, zero.policy = TRUE)

# Afficher les r√©sultats
kable(moran_result[["estimate"]], caption = "R√©sultats du test de Moran")

```

Ainsi dans notre √©tude, nous avons trouv√© un indice de Moran √©gale √†
`r moran_result[["estimate"]][["Moran I statistic"]]`. Le test nous a
permi d'obtenir une p-value de `r moran_result[["p.value"]]`. Ce qui
permet de conclure qu'il y a effectivement une autocorr√©lation positive
et significative entre les communes selon leur taux de consultations.


# Discussion

# Conclusion

# R√©f√©rences bibliographiques


# Annexes

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{../cartes/nombre_de_consulatations}
    \caption{Carte du nombre de consultations par commune}
    \label{fig:figure}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{../cartes/taux_de_consultations}
    \caption{Carte du taux de consultations par commune}
    \label{fig:figure}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{../cartes/taux_de_consultations_plus_19_ans}
    \caption{Carte du taux de consultations par commune pour les plus de 19 ans}
    \label{fig:figure}
\end{figure}
