---
output: 
  pdf_document: 
    keep_tex: true
---


```{r}
# Chargement des packages
library(stringi)
library(dplyr)
library(knitr)
library(kableExtra)
library(tidyr)
library(tidyverse)
library(summarytools)
library(gridExtra)
library(purrr)
library(skimr)
library(spdep)
library(geosphere)
```


```{r }
# Importation des donn√©es de d√©monstration

demo <- read.csv("../data/demof2.csv", sep = ";", dec=",")
#View(demo)
#str(demo)
names(demo)[names(demo) == "Libell√©"] <- "libelle_maj"

## Fonction prenant en entr√©e un base et nettoie les noms des colonnes

nettoyer_noms_colonnes <- function(data){
  names(data) <- names(data) %>%
    stri_trans_general("Latin-ASCII") %>% # Suppression des accents
    gsub("\\s+", "_", .) %>% # Remplacement des espaces par des underscores
    gsub("\\.+", "_", .) %>% # Remplacement des points par des underscores
    tolower() # Conversion en minuscules
  return (data) 
}

## Nettoyage des colonnes de la base demo
demo <- nettoyer_noms_colonnes(demo)
#names(demo)


# Fusion des bases et cr√©ation des varaiables

## Importation de la base generalise
generalise <- read.csv("../data/generalise.csv", sep=";")
#str(generalise)

## Importation de la base pour les lon et lat manquantes
donnees_manquantes <- read.csv(
  "../data/communes_manquantes_latitudes_longitudes.csv", sep=";", dec=".")
#str(donnees_manquantes)

donnees_manquantes$longitude <- donnees_manquantes$longitude %>%
  str_replace_all(",", "") %>%  # Supprime les virgules
  as.numeric()

## Nettoyage dans les noms des colonnes
generalise <- nettoyer_noms_colonnes(generalise)
donnees_manquantes <- nettoyer_noms_colonnes(donnees_manquantes)

## Fusion des bases
data <- demo %>% 
  inner_join(generalise, by ="code") %>%
  left_join(donnees_manquantes, by = "code") %>%
  mutate(
    longitude = ifelse(is.na(longitude.x), longitude.y, longitude.x),
    latitude = ifelse(is.na(latitude.x), latitude.y, latitude.x)
  ) %>%
  select(-longitude.x, -longitude.y, -latitude.x, -latitude.y)


#nrow(demo)
#nrow(generalise)
#nrow(data)

## Filtrons les communes n'appartenant pas au d√©partement 97
data <- data %>% filter(departement != 97)



## Cr√©ation de la variable taux de visites
data <- data %>% 
  mutate(taux_visites = nb_visite/population_municipale_2021_x)

## Cr√©ation de la variabe taux de visites pour les plus de 19 ans
data <- data %>%
  mutate(pop_19_ans_ou_plus = pop_15_ans_ou_plus - pop_15_19_ans,
       taux_visites_19_ans_ou_plus = nb_visite / pop_19_ans_ou_plus)

#summary(data$taux_visites)
#summary(data$taux_visites_19_ans_ou_plus)

#skim(data)




## Exportation de la base finale 
write.csv(data, "../data/data.csv", row.names = FALSE)

```

# Analyse descriptive

1. Description de la population d'√©tude 


Notre population d'√©tude est une population assez homog√®ne en mati√®re d'√¢ge. Cependant plus on d√©passe les 75 ans et moins on rencontre de personnes. D'autres part notre popuplation est fortement masculine avec une forte proportion des hommes quelle que soit la tranche d'√¢ge √† l'exception des tranches du troisi√®me √¢ge. 

```{r , fig.align='center', fig.cap= "Pyramide des √¢ges"}
library(ggplot2)
library(dplyr)
library(tidyr)
df = data
colnames(df) <- gsub("homme_", "hommes_", colnames(df))
colnames(df) <- gsub("hommes_70_47$", "hommes_70_74", colnames(df))



# S√©lectionner les colonnes de la pyramide des √¢ges
age_groups <- c("0_4", "5_9", "10_14", "15_19", "20_24", "25_29", "30_34", "35_39",
                "40_44", "45_49", "50_54", "55_59", "60_64", "65_69", "70_74",
                "75_79", "80_84", "85_89", "90_94", "95_plus")

# Restructurer les donn√©es pour la visualisation
hommes_vars <- intersect(colnames(df), paste0("hommes_", age_groups))
femmes_vars <- intersect(colnames(df), paste0("femmes_", age_groups))

# Cr√©er la pyramide des √¢ges avec les hommes d'abord, puis les femmes
pyramide <- data.frame(
  Age = rep(age_groups, 2),  # Liste tous les √¢ges d'abord pour les hommes, puis pour les femmes
  Sexe = c(rep("Homme", length(age_groups)), rep("Femme", length(age_groups))),
  Population = c(-colSums(df[paste0("hommes_", age_groups)], na.rm=TRUE),
                 +colSums(df[paste0("femmes_", age_groups)], na.rm=TRUE))  # Hommes en n√©gatif
)


# Convertir Age en facteur ordonn√© pour garantir le bon ordre
pyramide$Age <- factor(pyramide$Age, levels = age_groups, ordered = TRUE)


ggplot(pyramide, aes(x=Age, y=Population, fill=Sexe)) +
  geom_bar(stat="identity", width=0.8) +
  coord_flip() +  # Pour afficher en pyramide
  scale_y_continuous(labels = abs) +  # Afficher les valeurs absolues
  labs(
       x="Tranche d'√¢ge",
       y="Population",
       fill="Sexe") +
  theme_minimal() +
  scale_fill_manual(values=c("pink", "blue"))  # Couleurs pour Femme/Homme


```


Dans cette partie, nous allons r√©aliser quelques statistiques
descriptives sur nos donn√©es.

## Analyse univari√©e

```{r }
# Stats desc sur le nombre de visites
stats <- summary(data$nb_visite) 

# Sous forme de data frame
summary_df <- data.frame(
  Statistique = names(stats),
  Valeur = as.numeric(stats)
  ) %>%
  pivot_wider(names_from = Statistique, values_from = Valeur) 

# G√©n√©ration du tableau en LaTeX
summary_df %>% kable(format = "latex", 
                     booktabs = TRUE,
                     caption = "R√©sum√© statistique du nombre de visites") %>%
  kable_styling(latex_options = c("striped",
                                  "HOLD_position"))



```

1. Taux et Nombre de visites

L'analyse des statistiques descriptives sur le nombre de consultations
annuelles de m√©decin g√©n√©raliste entre 2018 et 2022 r√©v√®le une
distribution fortement asym√©trique √† droite, avec une grande dispersion
des donn√©es. La moyenne de 19130 consultations, nettement sup√©rieure √†
la m√©diane de 9127, indique la pr√©sence de valeurs extr√™mes tirant la
distribution vers le haut. Cette asym√©trie est confirm√©e par l'√©cart
consid√©rable entre le minimum de 1037 et le maximum de 765833
consultations par an.

La moiti√© des m√©decins g√©n√©ralistes effectuent entre 5993 et 17290
consultations annuellement, ce qui sugg√®re une variabilit√© importante
dans la charge de travail. La m√©diane de 9127 consultations par an,
√©quivalant √† environ 25 consultations par jour ouvrable, semble plus
repr√©sentative de l'activit√© typique d'un m√©decin g√©n√©raliste que la
moyenne influenc√©e par les valeurs extr√™mes. Ces statistiques mettent en
lumi√®re la diversit√© des pratiques et des charges de travail parmi les
m√©decins g√©n√©ralistes, avec potentiellement quelques cas atypiques
pr√©sentant un volume de consultations exceptionnellement √©lev√©.

Le nombre de visites pouvant potentiellement √™tre influenc√© par la
taille de la commune et donc par sa population, nous avons √©liminer cet
effet en calculant le taux de consultations qui n'est autre que le
nombre de consultations moyennes par personnes.

2. Taux de mortalit√© et de Natalit√©

Dans les commmunes √©tudi√©es, le taux de natalit√© et de mortalit√© sont un peu √©lev√©es avec la plupart des taux variant entre 5 et 15 pour 1000 en ce qui concerne la natalit√© et 0 et 20 pour 1000 pour la mortalit√©. On remarque une corr√©lation n√©gative entre ces deux taux. N√©anmoins cette corr√©lation n'a √† priori aucun sens. Par ailleurs, l'observation des distribution permet de constater que la natalit√© est nde fa√ßon g√©n√©rale √©lev√©e par rapport √† la mortalit√© dans les communes √©tudi√©es. 
```{r fig.align='center', fig.cap= "Taux de Natalit√© et Taux de Mortalit√©"}
# üìå V√©rification et conversion des variables avant de tracer
# V√©rification et conversion du taux de mortalit√©
if (class(df$taux_de_mortalite_annuel_moyen_2015_2021) != "numeric") {
  df$taux_de_mortalite_annuel_moyen_2015_2021 <- as.numeric(as.character(df$taux_de_mortalite_annuel_moyen_2015_2021))
}

# V√©rification et conversion du taux de natalit√©
if (class(df$taux_de_natalite_annuel_moyen_2015_2021) != "numeric") {
  df$taux_de_natalite_annuel_moyen_2015_2021 <- as.numeric(as.character(df$taux_de_natalite_annuel_moyen_2015_2021))
}

# üìå 1Ô∏è‚É£ Histogramme du taux de mortalit√©
p1 <- ggplot(df, aes(x = taux_de_mortalite_annuel_moyen_2015_2021)) +
  geom_histogram(bins = 30, fill = "red", alpha = 0.7, color = "black") +
  labs( 
       x = "Taux de mortalit√©", 
       y = "Nombre de communes") +
  theme_minimal()

# üìå 2Ô∏è‚É£ Histogramme du taux de natalit√©
p2 <- ggplot(df, aes(x = taux_de_natalite_annuel_moyen_2015_2021)) +
  geom_histogram(bins = 30, fill = "blue", alpha = 0.7, color = "black") +
  labs(
       x = "Taux de natalit√©", 
       y = "Nombre de communes") +
  theme_minimal()

# üìå 3Ô∏è‚É£ Nuage de points pour voir la relation entre mortalit√© et natalit√©
p3 <- ggplot(df, aes(x = taux_de_mortalite_annuel_moyen_2015_2021, 
                     y = taux_de_natalite_annuel_moyen_2015_2021)) +
  geom_point(alpha = 0.7, color = "purple") +
  geom_smooth(method = "lm", color = "black", linetype = "dashed") +  # Ajout d'une tendance lin√©aire
  labs(
       x = "Taux de mortalit√©",
       y = "Taux de natalit√©") +
  theme_minimal()

# üìå 4Ô∏è‚É£ Courbes de densit√© pour mieux voir la distribution
p4 <- ggplot(df) +
  geom_density(aes(x = taux_de_mortalite_annuel_moyen_2015_2021, fill = "Mortalit√©"), alpha = 0.5, color = "red") +
  geom_density(aes(x = taux_de_natalite_annuel_moyen_2015_2021, fill = "Natalit√©"), alpha = 0.5, color = "blue") +
  labs(
       x = "Taux",
       y = "Densit√©") +
  scale_fill_manual(values = c("Mortalit√©" = "red", "Natalit√©" = "blue")) +
  theme_minimal()

# üìå Affichage de tous les graphiques ensemble
library(gridExtra)
grid.arrange(p1, p2, p3, p4, ncol = 2)

```

```{r, fig.align='center', fig.cap= "R√©partition du nombre et du taux de consultations"}
library(ggplot2)
library(patchwork)

# Premier graphique pour nb_visite
plot1 <- ggplot(data) +
  aes(x = nb_visite) +
  geom_histogram(bins = 30L, fill = "gray") +
  theme_minimal() +
  ylab("Nombre de consultations") +
  xlab("")

# Deuxi√®me graphique pour taux_visites_19_ans_ou_plus
plot2 <- ggplot(data) +
  aes(x = taux_visites_19_ans_ou_plus) +
  geom_histogram(bins = 30L, fill = "gray") +
  theme_minimal() +
  ylab("Taux de consultations") +
  xlab("")

# Combinaison des deux graphiques
plot1 + plot2

```



## Analyse bivari√©e

Nous allons ici, voir s'il y a un lien √† priori entre le taux de
consultation et certaines de nos variables explicatives. Ainsi, nous
avons d'abord r√©alis√© une analyse descriptive bivari√©e puis nous avons
calcul√© la corr√©lation de Pearson pour √©valuer le lien lin√©aire entre le
taux de consulation et des variables telles que la population totale, la
part des personnes ag√©es (75 ans et plus), la part de quelques CSP
(ouvriers et retrait√©s).

### Taux de consultation et population totale
$\\$
```{r}
# Calcul des quantiles
quantiles <- quantile(data$population_municipale_2021_x, probs = c(1/3, 2/3), na.rm = TRUE)

# Cr√©eation des classes avec les bornes des intervalles
data_pop <- data %>%
  mutate(taille_commune = case_when(
    population_municipale_2021_x <= quantiles[1] ~ paste0("Petite (<= ", round(quantiles[1]), ")"),
    population_municipale_2021_x <= quantiles[2] ~ paste0("Moyenne (", round(quantiles[1] + 1), " - ", round(quantiles[2]), ")"),
    TRUE ~ paste0("Grande (> ", round(quantiles[2]), ")")
  )) %>%
  group_by(taille_commune) %>%
  summarise("Taux de consulations"= mean(taux_visites, na.rm = TRUE))

# G√©n√©ration du tableau en LaTeX
data_pop %>% kable(format = "latex", 
                     booktabs = TRUE,
                     caption = "Taux de consultations selon la taille de la commune") %>%
  kable_styling(latex_options = c("striped",
                                  "HOLD_position"))
```

En divisant les communes en trois groupes √©gaux (ou presque √©gaux) en
fonction de la population totale, il ressort qu'en moyenne, plus la
taille de la commune est importante plus le taux de consulations est
√©lev√©.


### Taux de consultation et population √¢g√©e

```{r}
# Calcul de la m√©diane
mediane <- median(data$nb_de_pers_agees_de_75_ans_ou_plus_2021, na.rm = TRUE)

# Cr√©eation des classes avec les bornes des intervalles
data_age <- data %>%
  mutate(population_agee_importante = case_when(
    nb_de_pers_agees_de_75_ans_ou_plus_2021 <= mediane ~ paste0("Non (<= ", round(mediane), ")"),
    TRUE ~ paste0("Oui (> ", round(mediane), ")")
  )) %>%
  group_by(population_agee_importante) %>%
  summarise(consultations_moyennes = mean(taux_visites, na.rm = TRUE))

# G√©n√©ration du tableau en LaTeX
data_age %>% kable(format = "latex", 
                     booktabs = TRUE,
                     caption = "Taux de consultations selon la population √¢g√©e") %>%
  kable_styling(latex_options = c("striped",
                                  "HOLD_position"))
```

```{r, fig.align='center', fig.cap="Relation entre taux de consultations et part des plus de 75 ans"}
ggplot(data = data, aes(x = part_des_pers_agees_de_75_ans_ou_2021 , y = taux_visites_19_ans_ou_plus)) +
  geom_point(color = "blue", size = 3) +          # Points bleus
  geom_smooth(method = "lm", se = TRUE, color = "red") +  # Droite de tendance (mod√®le lin√©aire)
  labs(
    x = "Part des plus de 75 ans",
    y = "Taux de consultation"
  ) +
  theme_minimal()

```

Les communes avec une population √¢g√©e importante (communes dont la
population √¢g√©e de 75 ans ou plus est sup√©rieure √† la m√©diane) ont en
moyenne un taux de consultations plus faible.


### Taux de consultation et CSP

```{r eval=FALSE, fig.align='center', fig.cap="Relations entre le taux de consultatiosn et certaines le nombre de certaines cat√©gories socioprofessionnelle", include=FALSE}
# Chargement les biblioth√®ques n√©cessaires
library(ggplot2)
library(gridExtra)

# Standarisation des variables pour prendre en compte l'effet de la taille des variables et rendre les comparaisons plus √©quitables
#data_csp <- data %>%
  #mutate(across(c(taux_visites, 13:20), scale))

data_csp <- data

# Cr√©ation les graphiques
plot1 <- ggplot(data_csp, aes(x = population_de_15_ans_ou_selon_la_csp_2021_agriculteurs_exploitants, y = taux_visites)) +
  geom_point() +
  labs(title = "", x = "Agriculteurs", y = "Taux de visites")

plot2 <- ggplot(data_csp, aes_string(x = names(data)[14], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Artisans", y = "Taux de visites")

plot3 <- ggplot(data_csp, aes_string(x = names(data)[15], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Cadres", y = "Taux de visites")

plot4 <- ggplot(data_csp, aes_string(x = names(data)[16], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Professions interm√©diaires", y = "Taux de visites")

plot5 <- ggplot(data_csp, aes_string(x = names(data)[17], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Employ√©s", y = "Taux de visites")

plot6 <- ggplot(data_csp, aes_string(x = names(data)[18], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Ouvriers", y = "Taux de visites")

plot7 <- ggplot(data_csp, aes_string(x = names(data)[19], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Retrait√©s", y = "Taux de visites")

plot8 <- ggplot(data_csp, aes_string(x = names(data)[20], y = "taux_visites")) +
  geom_point() +
  labs(title = "", x = "Sans activites", y = "Taux de visites")

# Affichage des graphiques ensemble
grid.arrange(plot1, plot2, plot3, plot4, plot5, plot6, plot7, plot8, ncol = 2)
```


Aucune cat√©gorie ne semble montrer une relation lin√©aire √©vidente avec
le taux de visite. Par ailleurs, pour toutes les cat√©gories
socio-professionnelles, la majorit√© des communes se situent dans une
plage de proportions faibles, ce qui limite la variabilit√© observable
dans les relations. Une analyse statistique suppl√©mentaire, comme le
calcul de corr√©lations, serait n√©cessaire pour confirmer ou infirmer les
relations observ√©es visuellement.

### Analyse de corr√©lation


Les r√©sultats de la corr√©lation de Pearson sont consign√©es dans le
tableau suivant :

```{r}
# Fonction de conversion
conversion_en_numeric <- function(data, columns) {
  resultat <- data %>%
    mutate(across(all_of(columns), as.numeric))
  return (resultat)
}
# Liste des variables √† tester avec taux_de_consultation
variables <- c("population_municipale_2021_x", "part_des_pers_agees_de_75_ans_ou_2021", 
               "population_de_15_ans_ou_selon_la_csp_2021_retraites", "population_de_15_ans_ou_selon_la_csp_2021_ouvriers")

data <- conversion_en_numeric(data, variables)


# Initialisation du tableau pour stocker les r√©sultats
resultats <- data.frame(Variable = character(), Correlation = numeric(), P_value = numeric())

# Calcul de la corr√©lation pour chaque variable et tester la significativit√©
for (var in variables) {
  test <- cor.test(data$taux_visites_19_ans_ou_plus, data[[var]], method = "pearson")
  resultats <- rbind(resultats, data.frame(
    Variable = var,
    Correlation = test$estimate,
    P_value = test$p.value
  ))
}

# Format du tableau avec la significativit√©
resultats$Significatif <- ifelse(resultats$P_value < 0.05, "Oui", "Non")

# G√©n√©ration du tableau en LaTeX
resultats %>% kable(format = "latex", 
                     booktabs = TRUE,
                     caption = "Corr√©lations de Pearson entre le taux de consultation et les autres variables")%>%
  kable_styling(latex_options = c("striped",
                                  "HOLD_position"))

```

Les r√©sultats nous montrent que le taux de consultation est positivement
corr√©l√© √† la population ainsi qu'√† celle de plus de 15 ans. Cependant la
corr√©lation est faible. Par ailleurs, la corr√©lation est n√©gative avec
la part des personnes ag√©es de plus de 75 ans. Cela dit, plus la part
des plus de 75 ans augmente moins est le taux de consultations dans une
commune. Cela peut vouloir dire que les personnes de plus de 75 ans sont
ceux qui ne se consultent pas assez.

```{r, fig.align='center', fig.cap= "Corr√©lations entre le nombre de visite et quelques variables"}
# S√©lectionner uniquement les variables d'int√©r√™t
# üìå D√©finition des noms lisibles pour les variables
nom_variables <- c(
  "taux_de_mortalite_annuel_moyen_2015_2021" = "Mortalit√©",
  "taux_de_natalite_annuel_moyen_2015_2021" = "Natalit√©",
  "part_des_familles_sans_enf_de_de_25_ans_2021" = "Sans enfants",
  "part_des_familles_avec_1_enf_de_de_25_ans_2021" = "Un enfant",
  "part_des_familles_avec_3_enf_ou_plus_de_de_25_ans_2021" = "Trois enfants",
  "nb_visite" = "Nombre de visites"
)

# üìå S√©lectionner les variables d'analyse
variables_analyse <- names(nom_variables)

df_analyse <- df[variables_analyse]

# üìå Convertir toutes les colonnes en num√©rique
df_analyse <- df_analyse %>% mutate(across(everything(), as.numeric))

# üìå Supprimer les valeurs manquantes
df_analyse <- na.omit(df_analyse)  

# üìå Calculer les corr√©lations
cor_matrix <- cor(df_analyse, use="complete.obs")

# üìå Trier les corr√©lations par ordre d√©croissant
cor_target <- sort(cor_matrix["nb_visite", ], decreasing=TRUE)

# üìå Remplacer les noms de variables par des noms plus lisibles
cor_data <- data.frame(
  Variable = names(cor_target),
  Correlation = cor_target
)

# üìå Appliquer les nouveaux noms
cor_data$Variable <- nom_variables[cor_data$Variable]

# üìå Exclure "Nombre de visites" du graphique
cor_data <- cor_data[cor_data$Variable != "Nombre de visites", ]

# üìå Afficher le barplot des corr√©lations
ggplot(cor_data, aes(x = reorder(Variable, Correlation), y = Correlation, fill = Correlation)) +
  geom_bar(stat="identity") +
  coord_flip() +
  scale_fill_gradient2(low="blue", mid="white", high="red", midpoint=0) +
  labs(
       x="Variables",
       y="Coefficient de corr√©lation") +
  theme_minimal()

```


## Autocorr√©lation

L‚Äôautocorr√©lation spatiale est une mesure essentielle pour analyser la
d√©pendance entre des observations g√©ographiques. Dans notre √©tude nos
donn√©es sont des donn√©es portant sur des communes. Ainsi il peut exister
une d√©pendance entre nos taux de consultations du fait de la proximit√©
des communes ou de l'appartenance √† un m√™me d√©partement ou r√©gion. Ainsi
nous allons mesurer cette d√©pendance en √©valuant l'autocorr√©lation
spatiale. Dans ce contexte, **l‚Äôindice de Moran** est largement utilis√©
pour quantifier cette d√©pendance en fournissant une mesure globale de
l‚Äôautocorr√©lation spatiale.

### D√©finition de l‚Äôindice de Moran

L‚Äôindice de Moran ($I$) √©value la similitude des valeurs d‚Äôune variable
entre diff√©rentes entit√©s g√©ographiques (par exemple, des communes) en
fonction de leur proximit√© spatiale. Il se base sur la matrice de poids
spatiale ($W$), qui d√©finit les relations entre ces entit√©s.

### Formule de l‚Äôindice de Moran

La formule math√©matique de l‚Äôindice de Moran est la suivante :

$$
I = \frac{n}{\sum_{i=1}^n \sum_{j=1}^n w_{ij}} \cdot \frac{\sum_{i=1}^n \sum_{j=1}^n w_{ij} (x_i - \bar{x})(x_j - \bar{x})}{\sum_{i=1}^n (x_i - \bar{x})^2}
$$

O√π :

-   $n$ : Nombre total d‚Äôentit√©s spatiales (Ici, le nombre de communes).

-   $x_i, x_j$ : Valeurs observ√©es de la variable pour les entit√©s $i$
    et $j$ (Ici le taux de consultations)

-   $\bar{x}$ : Moyenne de la variable $x$.

-   $w_{ij}$ : Poids spatial d√©finissant la relation entre $i$ et $j$.

La matrice de $W$ peut √™tre constuit sur la base du voisinage entre les
deux communes ou soit de la distance entre les deux communes. Dans le
premier cas alors $w_{ij}$ $w_{ij} = 1$ si $i$ et $j$ sont voisins et
$w_{ij} = 0$ sinon. Dans le second cas $w_{ij} = d_{ij}$. Nous allons
dans notre cas utiliser une matrice de poids bas√©e sur la distance,
notamment celle d'Haversine.

### Matrice de poids bas√©e sur la distance de Haversine

La distance de Haversine est une mesure de la distance entre deux points
sur une sph√®re, bas√©e sur leurs coordonn√©es g√©ographiques ($latitude$ et
$longitude$). Elle est particuli√®rement utile pour les donn√©es
g√©ographiques projet√©es sur une surface sph√©rique, comme la Terre.


### Formule de la distance de Haversine

Si l'on consid√®re deux points ($i$) et ($j$), la distance ($d_{ij}$)
entre ces deux points sur la surface d'une sph√®re de rayon ($r$) est
donn√©e par :

$$
 d_{ij} = 2r \cdot \arcsin\left(\sqrt{\sin^2\left(\frac{\phi_j - \phi_i}{2}\right) + \cos(\phi_i)\cos(\phi_j)\sin^2\left(\frac{\lambda_j - \lambda_i}{2}\right)}\right)
$$


O√π : 

- $r$ : Rayon de la Terre (environ 6371 km).

-   $\phi_i, \phi_j$ : Latitudes des points $i$ et $j$ (en radians).

-   $\lambda_i, \lambda_j$ : Longitudes des points $i$ et $j$ (en radians). Apr√®s calcul nous avons ces statistiques sur nos distances.

```{r}
# Charger les biblioth√®ques n√©cessaires

#  (latitude, longitude)
library(spdep)     # Pour les fonctions de pond√©ration spatiale et test de Moran
library(geosphere) # Pour les calculs de distances g√©od√©siques

# V√©rification que les colonnes latitude et longitude existent dans `data`
if (!("latitude" %in% names(data)) || !("longitude" %in% names(data))) {
  stop("Les colonnes 'latitude' et 'longitude' doivent exister dans la base de donn√©es.")
}

# V√©rification des valeurs manquantes dans les coordonn√©es
if (anyNA(data$latitude) || anyNA(data$longitude)) {
  stop("Les colonnes 'latitude' et 'longitude' ne doivent pas contenir de valeurs manquantes.")
}

# Cr√©ation de la matrice des coordonn√©es
coords <- data.frame(
  lat = data$latitude,
  lon = data$longitude
)

# Calcul des distances g√©od√©siques (en m√®tres) avec la m√©thode de Vincenty
dist_matrix <- distm(coords, fun = distVincentySphere)/1000

# G√©rer les distances nulles ou infinies
if (any(diag(dist_matrix) != 0)) {
  diag(dist_matrix) <- 0  # Auto-distance d√©finie comme 0
}
if (any(is.infinite(dist_matrix))) {
  stop("La matrice des distances contient des valeurs infinies, v√©rifiez les coordonn√©es.")
}

# R√©sum√© statistique de toutes les distances
distance_values <- as.vector(dist_matrix)
#summary(distance_values)
```

Une visualtion de la densit√© de nos distance nous donne ceci, indiquant une forte asym√©trie √† gauche de la distribution. En d'autres termes,les communes √©tudi√©es sont assez rapproch√©es les unes des autres pour la plupart. 

```{r fig.align='center', fig.cap="Densit√© des distances"}
dist_df <- data.frame(Distance = as.vector(dist_matrix))
# Tracer la densit√©
ggplot(dist_df, aes(x = Distance)) +
  geom_density(fill = "blue", alpha = 0.4) +
  theme_minimal() +
  labs(x = "Distance", y = "Densit√©")

```

### Construction de la matrice de poids

\
Pour construire la matrice de poids, nous avons alors suivi ces √©tapes.
\

1.  Calculer les distances de Haversine entre chaque paire d‚Äôentit√©s.
2.  D√©finir un seuil de distance maximale ($d_{max}$) :
    -   Si $d_{ij} < d_{max}$, $w_{ij} = \frac{1}{d_{ij}}$.
    -   Sinon, $w_{ij} = 0$.
3.  Normaliser les poids pour que chaque ligne de la matrice ait une
    somme √©gale √† 1 : $$
     w_{ij}^{norm} = \frac{w_{ij}}{\sum_{j} w_{ij}}.
    $$

```{r}
# Cr√©er la matrice de poids (inverse des distances)
weight_matrix <- 1 / dist_matrix
diag(weight_matrix) <- 0  # Aucun poids pour soi-m√™me

# G√©rer les cas o√π les distances sont nulles ou infinies
weight_matrix[is.infinite(weight_matrix)] <- 0

# Cr√©er l'objet spatial de pond√©ration
W <- mat2listw(weight_matrix, style = "W")

# V√©rifier que la variable √† analyser existe et ne contient pas de NA
if (!("taux_visites_19_ans_ou_plus" %in% names(data))) {
  stop("La colonne 'taux_visites_19_ans_ou_plus' doit exister dans la base de donn√©es.")
}
values <- data$taux_visites_19_ans_ou_plus

if (anyNA(values)) {
  stop("La colonne 'taux_visites_19_ans_ou_plus' ne doit pas contenir de valeurs manquantes.")
}

# Calcul de l'indice de Moran
moran_result <- moran.test(values, W, zero.policy = TRUE)

# G√©n√©ration du tableau en LaTeX
moran_result[["estimate"]] %>% kable(format = "latex", 
                     booktabs = TRUE,
                     caption = "R√©sultats du test de Moran") %>%
  kable_styling(latex_options = c("striped",
                                  "HOLD_position"))
```


Ainsi dans notre √©tude, nous avons trouv√© un indice de Moran √©gale √†
`r moran_result[["estimate"]][["Moran I statistic"]]`. Le test nous a
permi d'obtenir une p-value de `r moran_result[["p.value"]]`. Ce qui
permet de conclure qu'il y a effectivement une autocorr√©lation positive
et significative entre les communes selon leur taux de consultations.
